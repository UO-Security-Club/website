<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>UOSec</title>

    <!-- Bootstrap Core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../css/resources.css" rel="stylesheet">

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="index.html">Home</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                        <li>
                                <a href="../resources.html">Resources</a>
                        </li>
                    <li>
                        <a href="../info.html">Info</a>
                    </li>
                    <li>
                        <a href="../challenges.html">Challenges</a>
                    </li>
                    <li>
                        <a href="../schedule.html">Schedule</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <header class="image-bg-fluid-height">
        <img class="img-responsive img-center" src="../Images/UOSEC_logo2.png" alt="">
    </header>

    <!-- Content Section -->
    <section>
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <h1 class="section-heading">Stack-Based Memory Corruption</h1>
                    <h2>Exploitation and Mitigation</h2><br>

                    <p class="lead section-lead">Virtual Address Space (32 bit ELFs):</p>
                    <p class="section-lead">The Virtual Address Space (VAS) is divided up into several memory segments, each with their own purpose, organization, and permissions. From a high-level perspective, the following diagram depicts a single running process’s Address Space Layout:
                    </p>
                    <img src="../Images/lecture_note_images/stack-based-mem-corruption/figure1.png" alt="figure1">
                    <p><i>figure 1</i></p>
                    <p class="section-lead">The virtual address space ranges from 0x00000000 to 0xFFFFFFFF with the Code and Data segments starting at lower addresses, and the Kernel and Stack starting at higher addresses. It’s important to note that the Stack and Heap segments grow towards each other, filling and opening the space in-between as the process executes.<br><br>
                    <b>Segment Descriptions:</b>
                    <li><b>Code: </b>Contains CPU instructions for executing the program</li>
                    <li><b>Data: </b>Stores initialized global variables</li>
                    <li><b>BSS: </b>Stores unitialized global variables</li>
                    <li><b>Heap: </b>Linked-list for dynamic memory allocation</li>
                    <li><b>Stack: </b>Contains CPU instructions for executing the program</li>
                    <li><b>Kernel: </b>Space reserved for kernel execution</li>
                    <br>
                    <i>*Note: the kernel segment is referred to as Kernel-land, and all other segments are commonly referred to as User-land or User-space.</i>
                    <br><br>
                    The starting addresses of each segment listed in the diagram only serve as examples and do not pertain to every system. If you’re curious about the explicit segment starting addresses for a particular binary on a UNIX/Linux based system, you can throw the binary into GDB and examine its memory mappings with “info proc mappings”. </p>
                    <img src="../Images/lecture_note_images/stack-based-mem-corruption/figure2.png" alt="figure2" width="945" height="352">
                    <p><i>figure 2</i></p>
                    <p class="section-lead">The above image describes the VAS layout of a 32-bit ELF binary named call_instr. The row outlined in red describes the Code segment, and going down the list, yellow describes the Heap, green describes the shared libraries, and purple describes the Stack. If you’re unfamiliar with gdb, the steps to view a program’s VAS layout are as follows:
                    <li>$gdb <_path/_to/_binary/_file></li>
                    <li>$gdb break <some_function_name></li>
                    <li>$gdb run</li>
                    <li>$gdb info proc mappings</li>
                    <br>
                    This will start a gdb shell, set a breakpoint in the program (at whatever function you named), then run the program as a child process of gdb, and stop execution of the child once the breakpoint has been reached. Since the process is loaded in memory and its execution has paused, we can view its VAS layout with the gdb command <i>“info proc mappings”.</i> The source code for the binary used is shown below, and was compiled on a 64-bit system with <i>gcc -m32 -mpreferred-stack-boundary=2 file_name.c -o prog_name:</i></p>
                    <img src="../Images/lecture_note_images/stack-based-mem-corruption/figure3.png" alt="figure3" width="360" height="480">
                    <p><i>figure 3</i></p>

                    <p class="lead section-lead">Stack Segment: </p>
                    <p class="section-lead">The stack segment is as it’s name implies; a LIFO data structure where data is pushed and popped from a stack. Each element on the stack is a stack frame pertaining to an in-progress function. Within each stack frame, are sub-elements representing local variable data for that particular function as well as two saved pointer values:
                    <li><b>Return Address: </b>4-byte address of the caller function’s next instruction to execute (usually an address within the Code segment or a shared library function)</li>
                    <li><b>Saved Base Pointer: </b>4-byte address of the caller function’s base address</li>
                    <br>
                    These two values need to be saved in order to resume execution of the caller function once the callee function has returned. In addition, two general-purpose processor registers are used in maintaining order of the stack:
                    <br><br>
                    <li><b>EBP (Extended Base Pointer): </b>Holds the base address of the currently executing function’s stack frame</li>
                    <li><b>ESP (Extended Stack Pointer): </b>Holds the current address of the top of the currently executing function’s stack frame (which implies the top of the stack segment as a whole)</li>
                    <br>
                    <i>*Note:  if you’re rusty on x86 general-purpose registers or unfamiliar with the x86 ISA, here’s a reading recommendation: <a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html">Guide to x86</a></i>
                    <br><br>
                    Looking back at the example program used in gdb earlier, if we were to pause execution right before foo1() returned, it’s stack would look similar to the following image:</p>
                    <p>[INSERT IMG 4]</p>

                    <p class="section-lead">The light-gray boxes represent main()’s stack frame, and the lower green boxes represent foo1()’s stack frame (RET denotes the Return Address).</p>
                    <br>
                    <p class="lead section-lead">Classic Stack Buffer Overflow: </p>
                    <p class="section-lead">In a classic stack buffer overflow scenario, the most straight-forward exploit method is to overwrite the Return Address of the vulnerable function with a different valid address. This is possible since data written to a buffer is written in the opposite direction than the stack grows. Additionally, even overwriting the saved Base Pointer can be used to subvert execution flow; a technique referred to as Stack-Pivoting (in case you’re interested in looking it up).
                    <br>
                    Let’s take a look at a basic example. Given the following source code:
                    <br><br>
                    <i>*Compiled with: gcc -m32 -mpreferred-stack-boundary=2 canary_example.c -o canary_example</i></p>
                    <img src="../Images/lecture_note_images/stack-based-mem-corruption/figure5.png" alt="figure5" width="40%" height="40%">
                    <p>figure5</p>

                    <p class="section-lead">In <i>func1</i> we have allocated a 32-byte buffer on the stack with the variable named <i>buf</i>. A call to Libc’s <i>fgets</i> function is then used to read a maximum of 64 bytes of data into <i>buf</i>. If fgets <i>fails</i> to read any data from stdin (unfamiliar with stdin or standard streams in general? Here’s a helpful link: <a href="http://bfy.tw/AoYs">Standard Streams</a>) then a NULL pointer is returned, in which case, the error variable is set to 1 and returned. Otherwise, error remains equal to 0 when returned. In this example program, we are interested in the fact that <i>fgets</i> has a size parameter of 64, but is reading data from stdin into a buffer of size 32. This means that we can overflow the buffer by 64 - 32 = 32 bytes. If we feed some ‘A’s as input to the program, this is what the stack segment will look like right after fgets returns but right before <i>func1</i> returns:
                    <br><br>
                    <i>*Note: main’s stack-frame is colored blue and func1’s is colored green.</i></p>
                    <p>[INSERT IMG 6]</p>

                    <p class="section-lead">As the diagram attempts to demonstrate, user input data is being written towards saved data on the stack, such as <i>func1’s</i> error variable and even main’s stack-frame. If we provide, say 33 bytes of input data, then we can overwrite the first byte of <i>func1’s error</i> variable. Since main assumes an error occurred if <i>func1’s</i> return value is nonzero, we can easily test for the buffer overflow by providing 33 bytes of data and checking if the program prints “Failed to read input data”.
                    <br><br>
                    <i>*Note: that in the below example, providing 32 ‘A’s as input corrupted the error variable because a newline ‘\n’  character was appended to the end of our input by python’s print function, increasing the input size to 33 bytes.</i></p>
                    <p>[INSERT IMG 7]</p>

                    <p class="section-lead">As we can see from the above example, overflowing the buffer by 1 byte corrupted <i>func1’s error</i> variable. Even though our input was written to the buffer successfully, main received a nonzero return value from <i>func1</i> and assumed an error occurred, causing “Failed to read input data” to be printed to the terminal. Here’s what the stack segment would look like (roughly) right before <i>func1</i> returns after providing 32 ‘A’s as input:</p>
                    <p>[INSERT IMG 8]</p>

                    <p class="section-lead">Of course, we could write further up the stack and corrupt the saved EBP and EIP (Return Address) values to subvert execution flow, which will be demonstrated shortly. So, aside from ruling out human error in programming (a bit unreasonable to expect), how can we defend against or prevent buffer overflows?</p>
                    <br><br>
                    <p class="lead section-lead">Stack Canary: (Compiler Implemented)</p>
                    <p class="section-lead">Also referred to as a stack cookie, a canary is a randomly generated 4-byte value that is placed in a stack frame directly on top of a buffer. The canary value is generated at run time and moved to the stack immediately after the function prologue. When said function is about to return, the canary value is validated for any corruption. If the canary value has been modified, then the function will not return and instead the process will exit. The security that stack canaries provide is dependent on the fact that overflowing a buffer overwrites all data on the stack in between the end of the buffer and the end of the overflow. Since the canary is placed directly at the end of the buffer, even a single-byte overflow will overwrite the first byte of the canary.
                    <br>
                    We can modify the previous buffer overflow example program to mimic a stack canary:</p>
                    <img src="../Images/lecture_note_images/stack-based-mem-corruption/figure9.png" alt="figure3" width="500" height="600">
                    <p><i>figure 9</i></p>

                    <p class="section-lead">Now, if we overflow buf with input size greater than 32, the first byte of the canary variable will be overwritten. Here’s what the stack would roughly look like right before func1 returns:
                    <i>*Note: the reason that our canary value looks mangled is because it’s bytes are in reverse order (e.g. Little Endian. Here’s a good resource link on Endianness if you need it: <a href="http://bfy.tw/39vC">Endianness</a>)</i></p>
                    <p>[INSERT IMG 10]</p>

                    <p class="section-lead">Here’s the results of testing our super-secure canary:</p>
                    <p>[INSERT IMG 11]</p>

                    <p class="section-lead">We can see that providing 15 bytes of input caused no issues, however, 36 bytes of input corrupted our canary value and execution of main never resumed; program exited cleanly.<br><br>
                    Unfortunately our super-secure canary required modification of the source code by adding an extra variable and conditional statement. In which case, if our program was several thousand lines of code, we’d have to add this in every function with a buffer… Not exactly ideal from a programming perspective. Thankfully we can use gcc (GNU C Compiler) to implement the stack canaries for us automagically with the -fstack-protector or -fstack-protector-all flags. From the gcc manual pages ( <a href="https://linux.die.net/man/1/gcc">gcc man pages</a>):<br><br>
                    <hr>
                    <b>-fstack-protector: </b><br>
                    Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call alloca, and functions with buffers larger than 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits.<br><br>
                    <b>-fstack-protector-all: </b><br>
                    Like -fstack-protector except that all functions are protected.<hr><br><br>
                    If we recompile our previous program using gcc’s stack-protection:<br>
                    <i>gcc -m32 -mpreferred-stack-boundary=2 canary_example.c -o canary_example2 <b>-fstack-protector</b></i><br>
                    We can then look at the disassembly of <i>func1</i> for gcc’s canary implementation:<br><br>
                    <hr>
                    <br>gdb$ disassemble func1 
                    <br>Dump of assembler code for function func1:
                    <br>0x080484cb <+0>:    push   ebp
                    <br>0x080484cc <+1>:    mov    ebp,esp
                    <br>0x080484ce <+3>:    sub    esp,0x2c
                    <br>0x080484d1 <+6>:    mov    eax,gs:0x14
                    <br>0x080484d7 <+12>:   mov    DWORD PTR [ebp-0x4],eax
                    <br>0x080484da <+15>:   xor    eax,eax
                    <br>0x080484dc <+17>:   mov    DWORD PTR [ebp-0x2c],0x0
                    <br>0x080484e3 <+24>:   mov    DWORD PTR [ebp-0x28],0xdeadbeef
                    <br>0x080484ea <+31>:   mov    eax,ds:0x804988c
                    <br>0x080484ef <+36>:   push   eax
                    <br>0x080484f0 <+37>:   push   0x40
                    <br>0x080484f2 <+39>:   lea    eax,[ebp-0x24]
                    <br>0x080484f5 <+42>:   push   eax
                    <br>0x080484f6 <+43>:   call   0x8048370 <fgets@plt>
                    <br>0x080484fb <+48>:   add    esp,0xc
                    <br>0x080484fe <+51>:   test   eax,eax
                    <br>0x08048500 <+53>:   je     0x8048524 <func1+89>
                    <br>0x08048502 <+55>:   cmp    DWORD PTR [ebp-0x28],0xdeadbeef
                    <br>0x08048509 <+62>:   je     0x804851f <func1+84>
                    <br>0x0804850b <+64>:   push   0x8048610
                    <br>0x08048510 <+69>:   call   0x8048390 <puts@plt>
                    <br>0x08048515 <+74>:   add    esp,0x4
                    <br>0x08048518 <+77>:   push   0x1
                    <br>0x0804851a <+79>:   call   0x80483b0 <exit@plt>
                    <br>0x0804851f <+84>:   mov    eax,DWORD PTR [ebp-0x2c]
                    <br>0x08048522 <+87>:   jmp    0x804852e <func1+99>
                    <br>0x08048524 <+89>:   mov    DWORD PTR [ebp-0x2c],0x1
                    <br>0x0804852b <+96>:   mov    eax,DWORD PTR [ebp-0x2c]
                    <br>0x0804852e <+99>:   mov    edx,DWORD PTR [ebp-0x4]
                    <br>0x08048531 <+102>:  xor    edx,DWORD PTR gs:0x14
                    <br>0x08048538 <+109>:  je     0x804853f <func1+116>
                    <br>0x0804853a <+111>:  call   0x8048380 <__stack_chk_fail@plt>
                    <br>0x0804853f <+116>:  leave  
                    <br>0x08048540 <+117>:  ret    
                    <br>End of assembler dump.
                    <br>gdb$ 
                    <hr><br><br>
                    </p>
                </div>
            </div>
        </div>
    </section>
    </section>

    <!-- Fixed Height Image Aside -->
    <!-- Image backgrounds are set within the full-width-pics.css file. -->
    <aside class="image-bg-fixed-height"></aside>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <p>Copyright &copy; UOSec \x80\x01\x32\x0F</p>
                </div>
            </div>
            <!-- /.row -->
        </div>
        <!-- /.container -->
    </footer>

    <!-- jQuery -->
    <script src="../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../js/bootstrap.min.js"></script>

    <!-- Modal Script -->
    <script src="../js/modalScript.js"></script>
</body>
</html>






